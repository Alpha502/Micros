ORG 0000H
JMP MAIN
ORG 0003H
JMP KEYBOARD_INPUT // Interrupción INT0
ORG 0013H
JMP KEYBOARD_INPUT_2 // Interrupción INT1
ORG 00040H
MAIN:
	ACALL RESET_MEMORY
	ACALL INIT_LCD_DISPLAY
	ACALL INIT_INTERRUPTIONS
	ACALL INIT_SERIAL_TIMER
MAIN_LOOP:
	JNB P3.4, $
	INC R6
	SETB P0.3
	JB P3.4, $
	CJNE R6, #00H, $ // Esperar a que keyboardCounter sea reseteado por la interrupción, para poder recibir otro input
	JMP main_loop
KEYBOARD_INPUT: // Interrupción 1, leer el dato del teclado matricial, guardarlo en memoria RAM y enviarlo a la pantalla LCD. Si keyboardInput está en 2, estamos en modo ASCII
	CJNE R6, #02H, KEYBOARD_INPUT_1
	MOV A, R4
	ADD A, P2
	MOV R4, A
	MOV R6, #00H
	ACALL LCD_SEND_DATA
	CLR P0.3
	RETI
KEYBOARD_INPUT_1: // Si no es dos, revisamos si es 1 para guardar el input en el acumulador
	CJNE R6, #01H, KEYBOARD_INPUT_NORMAL
	MOV A, P2
	SWAP A
	MOV R4, A
	INC R6
	RETI
KEYBOARD_INPUT_NORMAL: // Si no es 1 ni 2, guardamos el input del teclado y lo enviamos
	MOV A, P2
	ACALL CHANGE_TO_ASCII
	MOV R4, A
	ACALL LCD_SEND_DATA
	RETI
KEYBOARD_INPUT_2: // Enviar los datos guardados en la memoria ram por serial
	MOV R1, #30H
MEMORY_LOOP:
	MOV A, @R1
	ACALL SEND_ACC_SERIAL
	INC R1
	CJNE R1, #50H, MEMORY_LOOP
	RETI
RESET_MEMORY:
	MOV R4, #00H
	MOV R2, #00H
	MOV R3, #01H
	MOV R0, #030H
	MOV R6, #00H
	SETB P3.4
	CLR P0.3
	CLR P0.2
	CLR P0.1
	CLR P0.0
	CLR TI
	MOV R1, #30H
MEMORY_RESET_LOOP:
	MOV @R1, #00H
	INC R1
	CJNE R1, #50H, MEMORY_RESET_LOOP
	RET
RESET_RAM_AND_LCD:
	MOV R1, #30H
	MOV R4, #01H
	ACALL LCD_SEND_INSTRUCTION
	ACALL LCD_CHANGE_ROW_TO_1
RESET_RAM_AND_LCD_LOOP:
	MOV @R1, #00H
	INC R1
	CJNE R1, #50H, RESET_RAM_AND_LCD_LOOP
	RET
INIT_SERIAL_TIMER: // Iniciar el timer 1 para poder transmitir a 9600 baudios
	MOV SCON, #01000000B
	MOV TMOD, #00100000B
	MOV TH1, #0FDH
	MOV TL1, #(-3)
	SETB TR1
	RET
INIT_LCD_DISPLAY:
	MOV R4, #38H
	ACALL LCD_SEND_INSTRUCTION
	ACALL LONG_DELAY
	MOV R4, #38H
	ACALL LCD_SEND_INSTRUCTION
	ACALL LONG_DELAY
	MOV R4, #38H
	ACALL LCD_SEND_INSTRUCTION
	ACALL LONG_DELAY
	MOV R4, #01H
	ACALL LCD_SEND_INSTRUCTION
	ACALL LONG_DELAY
	MOV R4, #0FH
	ACALL LCD_SEND_INSTRUCTION
	ACALL LONG_DELAY
	RET
LCD_SEND_DATA:
	SETB P0.2
	MOV P1, R4
	SETB P0.0
	NOP
	CLR P0.0
	ACALL SHORT_DELAY
	ACALL STORE_R4
	RET
LCD_SEND_INSTRUCTION:
	CLR P0.2
	MOV P1, R4
	SETB P0.0
	NOP
	CLR P0.0
	RET
INIT_INTERRUPTIONS:
	MOV IE, #10000101B
	SETB IT0
	SETB IT1
	RET
STORE_R4:
	MOV A, R4
	MOV @R0, A
	INC R0
	CJNE R0, #40H, NO_CHANGE_1
	ACALL LCD_CHANGE_ROW_TO_2
NO_CHANGE_1:
	CJNE R0, #50H, NO_CHANGE_2
	ACALL RESET_RAM_AND_LCD
	MOV R0, #30H
	ACALL RESET_RAM_AND_LCD
NO_CHANGE_2:
	RET
LCD_CHANGE_ROW_TO_2:
	MOV R4, #0C0H
	ACALL LCD_SEND_INSTRUCTION
	RET
LCD_CHANGE_ROW_TO_1:
	MOV R4, #80H
	ACALL LCD_SEND_INSTRUCTION
	RET
SEND_ACC_SERIAL:
	MOV SBUF, A
	JNB TI, $
	CLR TI
	RET
CHANGE_TO_ASCII:
	MOV R5, A
ASCII_1:
	CJNE A, #00H, ASCII_2
	MOV A, R5
	ADD A, #30H
	RET
ASCII_2:
	CJNE A, #0AH, ASCII_3
	MOV A, R5
	ADD A, #37H
	RET
ASCII_3:
	DEC A
	SJMP ASCII_1
LONG_DELAY:
	MOV R3, #15H
SHORT_DELAY:
	MOV R2, #0FFH
	DJNZ R2, $
	DJNZ R3, SHORT_DELAY
	MOV R3, #1D
	RET
END
